# SQL

### ПОРЯДОК НАПИСАНИЯ ОПЕРАТОРОВ В ЗАПРОСЕ

```
SELECT 
FROM 
WHERE 
GROUP BY 
HAVING 
ORDER BY 
LIMIT; 
```

### ПОРЯДОК ВЫПОЛНЕНИЯ ОПЕРАТОРОВ В ЗАПРОСЕ

```
FROM
WHERE
GROUP BY
HAVING
SELECT
ORDER BY
LIMIT
```

#### Порядок операторов в запросе с оконными функциями
```
SELECT 
    [column_1], 
    [column_2],
    [window_function]() OVER [window_name]
FROM 
    [table_name]
WHERE 
    [...]
GROUP BY 
    [...]
HAVING 
    [...]
WINDOW [window_name] AS (
    PARTITION BY [...]
    ORDER BY [...]
    [window_frame])
ORDER BY 
    [...]
LIMIT;
```
### ПЕРЕВОД В ИНОЙ ТИП ДАННЫХ

```
toFloat64OrNull(column) -- перевод данных из str к числу с точкой
SELECT '2022-12-31'::DATE -- преобразование текста в дату
```

### РАБОТА С МАССИВАМИ

```
array_length() -- используется для определения длины массива
unnest() -- предназначена для разворачивания массивов и превращения их в набор строк
array_agg() -- агрегирующая функция, которая собирает все значения в указанном столбце в единый список (ARRAY)
```

### РАБОТА СО СТРОКАМИ
```
CONCAT('SQL', ' ', 'Simulator ', 2022) 
-- принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом
LOWER()
UPPER()
-- переводят символы строки в нижний и верхний регистры соответственно
LEFT() и RIGHT()
-- вырезают заданное количество символов слева и справа соответственно
LEN()
LENGTH()
-- считает количество символов строки
REPLACE()
-- заменяет часть строки. В скобках три аргумента: столбец, значение в столбце, которое нужно заменить,
-- и значение, на которое нужно заменить
SUBSTRING()
-- извлекает часть строки из строки. В скобках три аргумента:
-- столбец, номер символа, с которого нужно начать извлечение,
-- и количество символов, которые нужно извлечь
```

### УСЛОВНЫЕ ФУНКЦИИ
```
CASE  
WHEN logical_expression_1 THEN expression_1
WHEN logical_expression_2 THEN expression_2
```
```
ELSE expression_else
END AS case_example
-- если logical_expression_1 возвращает истинное значение, то выражение CASE вернёт expression_1,
-- иначе будет сделана проверка на logical_expression_2 и т.д.
-- если ни одно из предложенный условий не будет выполнено, то вернётся NULL
-- или возвращаемое_значение_по_умолчанию, если была использована конструкция ELSE
```
```
IF (logical_expression_1, expression_1, expression_2);
-- если условное выражение, передаваемое в качестве первого аргумента в функцию IF, истинно,
-- функция вернёт значение второго аргумента expression_1,
-- иначе возвращается значение третьего аргумента expression_2
```

### ФУНКЦИИ ДЛЯ РАБОТЫ С ЧИСЛАМИ

| функция   | описание работы                                      | пример работы         |
| --------- | --------------------------------------------- | -------------- |
| CEILING(x) | округляет x до целого числа в большую сторону | CEILING(2.2) = 3,<br> CEILING(-3.8) = -3 |
| ROUND(x, k) | округляет x до k знаков после запятой, если k не указано – до целого | ROUND(8.3631) = 8,<br> ROUND(2.74562, 1) = 2.7 |
| FLOOR(x)  | округляет до целого числа в меньшую сторону | FLOOR(9.3) = 9,<br> FLOOR(-7.8) = -8 |
| POWER(x, y) | возведение x в степень y                        | POWER(2, 3) = 8.0 |
| SQRT(x)   | квадратный корень из x                          | SQRT(16) = 4.0,<br> SQRT(9)=3.0. |
| DEGREES(x) | конвертирует x из радиан в градусы     | DEGREES(20) = 1145.91559026164 |
| RADIANS(x) | конвертирует x из градусов в радианы  | RADIANS(45)= 0.7853981633974483 |
| ABS(x)    | модуль числа x                                 | ABS(-5) = 5, ABS(5) = 5 |
| PI()      | выводит число pi                            | SELECT PI() = 3.141592653589793 |


### РАБОТА С ДАТАМИ
```
CAST(column as date_type) -- перевод колонки к формату с датой
DAY(), MONTH(), YEAR() -- извлекают из даты день, месяц и год соответственно
MONTHNAME(column) -- название месяца
MONTH(column) -- номер месяца из даты
GETDATE() -- возвращает текущую дату и время сервера в формате datetime (год, месяц, день, часы, минуты, секунды)
NOW() -- возвращает текущую дату и время сервера в формате datetime (год, месяц, день, часы, минуты, секунды)
INTERVAL '1 year 2 months 1 week' -- определяет промежуток времени
DATEPART(year, column) -- возвращает значение части даты и времени (год, месяц, день, час, минута, секунда)
DATEDIFF(datepart, startdate, enddate) -- вычисляет разницу между двумя датами в заданной единице измерения
TIMESTAMPDIFF(second, time_1, time_2) -- вычисляет разницу между двумя датами в заданной единице измерения
DATE_TRUNC('day', time_column) -- используется для обрезания времени по указанной величине
EXTRACT(YEAR FROM time_column) -- используется для извлечения компонентов даты или времени из даты или временной метки
WHERE date >= CURRENT_DATE - INTERVAL '30 days' --  отбирает строчки в которых дата в пределах последних 30 дней
DATEADD(day, 10, column) --  добавляет заданное количество времени к дате (дни, часы, минуты, секунды)
EXTRACT(DOW FROM column) -- возвращает дни недели из значений в формате TIMESTAMP
-- (в PostgreSQL дни недели представлены числами от 0 до 6, где 0 - воскресенье, 1 - понедельник)
AGE(column, column)::VARCHAR -- возвращает разницу между двумя значениями, представленными в формате TIMESTAMP
toStartOfMonth(toDateOrNull(column)) -- перевод str столбца к дате с заполнением пропусков (null) и приводом к старту месяца
to_char('2022-08-24 00:00:00'::timestamp, 'YYYY-MM-DD') -- преобразует дату в строку с заданным форматом
```
### ОТБОР ДАННЫХ
```
SELECT COALESCE(column, 'filler value') 
-- если значение в строке NULL, оно заменится на значение, указанное вторым аргументом
```
```
SELECT column_1, agg_function(column_2) FILTER (WHERE condition)
-- агрегатное выражение с фильтрацией
```
#### ИСПОЛЬЗОВАНИЕ ОПЕРАТОРА LIKE
| шаблон/символ | с чем совпадает? | пример работы | 
| ------------------------ | ------------------------- | -------------------------- |
| %     | строка, содержащая ноль или более символов      | SELECT * FROM list WHERE names LIKE '%П.М.%'<br>ищет все имена с инициалами П.М.     |
| _     | любой одиночный символ      | SELECT * FROM list WHERE names LIKE '_____'<br>ищет все имена состоящие из пяти любых символов     |

```
SELECT * FROM table
WHERE column LIKE '3!%' ESCAPE '!';
-- ESCAPE-символ используется для экранирования специальных символов
```

#### НЮАНСЫ АГРЕГАЦИИ
```
SELECT agg_function(column) FILTER (WHERE condition)
-- агрегирующей функции на вход будут поданы только те строки, для которых условие фильтра окажется истинным
```

### СОЗДАНИЕ И ИЗМЕНЕНИЕ ТАБЛИЦ
```
CREATE TABLE IF NOT EXISTS database_name.table_name ( 
    column_1 UInt32, -- колонка, тип данных
    column_2 UInt32,
    column_3 DateTime('Europe/Moscow'),
    column_4 String
    ) 
```
#### ПОДЧИНЕННЫЕ ТАБЛИЦЫ

В подчиненной таблице можно настроить, какие действия должны выполняться при удалении связанной строки из главной таблицы.<br> Доступны четыре опции:

CASCADE:<br> автоматически удаляет все связанные строки в подчиненной таблице при удалении строки из главной таблицы.<br>
SET NULL:<br> при удалении связанной строки из главной таблицы устанавливает значение NULL для соответствующего столбца в подчиненной таблице. Для этого столбца должна быть разрешена возможность принимать значение NULL.<br>
SET DEFAULT:<br> при удалении связанной строки из главной таблицы устанавливает значение по умолчанию для соответствующего столбца в подчиненной таблице.<br>
RESTRICT:<br> запрещает удаление строки из главной таблицы, если на нее ссылаются строки в подчиненной таблице.<br>
```
CREATE TABLE primary (
    id INT PRIMARY KEY AUTO_INCREMENT, 
    name VARCHAR(50) NOT NULL, 
    personal_number INT NOT NULL,
    phone_number INT,
    salary DECIMAL(8,2), 
    FOREIGN KEY (name)  REFERENCES secondary (name) ON DELETE CASCADE,
    FOREIGN KEY (id, salary)  REFERENCES secondary (primary_id, salary) ON DELETE SET NULL
);
```
### ПОДЗАПРОСЫ
```
SELECT 200 > ALL(SELECT column FROM table)
-- запрос проверяет для всех ли записей выполняется условие, что они меньше чем 200
```
```
SELECT 200 > ANY(SELECT column FROM table)
-- запрос проверяет, чтобы хотя бы для одной записи выполнялись условия, что она меньше чем 200
```
### ОБЪЕДИНЕНИЕ ТАБЛИЦ и ЗАПРОСОВ

#### ОБЪЕДИНЕНИЕ ТАБЛИЦ
```
SELECT column_1, column_2
FROM table_1, table_2
WHERE table_1.column_1 = table_2.column_3
-- для внутреннего соединения таблиц можно использовать оператор WHERE
```
#### ОПЕРАЦИИ С МНОЖЕСТВАМИ
```
select column_1, column_2
from table_1
union
select column_1, column_2
from table_2
-- объединяет результаты двух запросов из двух разных таблиц в один результат:
-- всего могут быть следующие варианты:
-- union: объединяет два списка и убирает дубли (объединение множеств);
-- union all: объединяет два списка с сохранением дублирующих строк;
-- except: из верхней таблицы оставляет уникальные строки, которые отсутствуют в нижней таблице (разница множеств);
-- intersect: оставляет уникальные строки, которые присутствуют и в верхней и в нижней таблицах (пересечение множеств)
```
### РЕКУРСИВНЫЕ ЗАПРОСЫ
```
WITH RECURSIVE temp_table AS (
    SELECT * FROM table WHERE column_1 = 2020
    UNION
    SELECT table.* FROM table
    JOIN temp_table ON table.column_1 = temp_table.column_1 
        OR table.column_2 = temp_table.column_2 OR table.column_3 = temp_table.column_3)
    SELECT DISTINCT * FROM temp_table;
-- данный запрос находит все строки из таблицы table, 
-- которые имеют совпадения по column_1, column_2 или column_3 с любой строкой, 
-- удовлетворяющей условию column_1 = 2020
```
### ОКОННЫЕ ФУНКЦИИ

#### СИНТАКСИС ОКОННЫХ ФУНКЦИЙ
```
OVER (
     PARTITION BY column_1, column_2, ...    -- определяются партиции внутри окна (аналог GROUP BY) 
     ORDER BY column_3, ...    -- указывается сортировка записей в партициях
     ROWS/RANGE BETWEEN ...    -- задаются границы окна
)
```
```
UNBOUNDED PRECEDING -- указывает, что рамка начинается с первой строки партиции
значение PRECEDING -- рамка начинается со сдвигом на заданное число строк относительно текущей строки
CURRENT ROW -- указывает, что рамка начинается или заканчивается на текущей строке
значение FOLLOWING -- рамка заканчивается со сдвигом на заданное число строк относительно текущей строки
UNBOUNDED FOLLOWING -- указывает, что рамка заканчивается на последней строке партиции
```

#### КАКИЕ ФУНКЦИИ ПРИМЕНЯЮТСЯ СОВМЕСТНО С ОКОННЫМИ ФУНКЦИЯМИ

##### АГРЕГИРУЮЩИЕ
```
SUM, AVG, MAX, MIN, COUNT
```
##### РАНЖИРУЮЩИЕ
```
ROW_NUMBER -- простая нумерация (1, 2, 3, 4, 5)
RANK -- нумерация с учётом повторяющихся значений с пропуском рангов (1, 2, 2, 4, 5)
DENSE_RANK -- нумерация с учётом повторяющихся значений без пропуска рангов (1, 2, 2, 3, 4)
```
##### ФУНКЦИИ СМЕЩЕНИЯ
```
LAG, LEAD -- значение предыдущей или следующей строки
FIRST_VALUE, LAST_VALUE -- первое или последнее значение в окне
```

#### АНАЛОГ ОКОННОЙ ФУНКЦИИ
```
SELECT DISTINCT ON (email) name, email
FROM clients
ORDER BY email, date DESC;
-- запрос сортирует результаты по полю email в порядке возрастания и по полю date_add в порядке убывания,
-- для каждого уникального значения поля email, в результате будет только одна запись, соответствующая самой последней дате
```

### ИЗМЕНЕНИЕ ДАННЫХ В ТАБЛИЦАХ
```
INSERT INTO Table (column_1, column_2, column_3)
VALUES (20, 'Example', 2);
-- запрос вносит новую строку в таблицу
```
```
UPDATE Table
SET column = "new_value"
WHERE column = "old_value";
-- запрос изменяет значение в таблице по условию, указанному в where
```
```
DELETE FROM Table
WHERE column = "old_value";
-- запрос удаляет строки в таблице по условию, указанному в where
```
