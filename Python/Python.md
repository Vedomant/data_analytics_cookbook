# Python

## <a name="import">Импорт библиотек</a>

`import pandas as pd`
> импортирует библиотеку для работы с таблицами и данными в виде датафреймов

`import numpy as np`
> импортирует библиотеку для работы с числами

`import seaborn as sns`
> импортирует библиотеку для создания графиков и визуализации данных

`import matplotlib.pyplot as plt`
> импортирует библиотеку для создания графиков и визуализации данных

`import plotly.express as px`
> импортирует библиотеку для создания интерактивных графиков

`import datetime`
> импортирует модуль для работы с датами и временем

`import matplotlib.dates as mdates`
> импортирует модуль для работы с датами и временем в библиотеке matplotlib

`import random`
> импортирует модуль для генерации случайных чисел

`import re`
> импортирует модуль для работы с регулярными выражениями

`import vk_ip`
> импортирует модуль для работы с IP-адресами ВКонтакте

`import os`
> импортирует модуль для работы с операционной системой

`import json as json`
> импортирует модуль для работы с JSON-данными

`import requests`
> импортирует модуль для работы с HTTP-запросами

`import gspread`
> импортирует библиотеку для работы с Google Sheets

`import zipfile`
> импортирует модуль, который предоставляет функции для работы с архивами ZIP в Python

`from io import BytesIO`
> импортирует модуль для работы с бинарными данными в памяти

`import pandahouse as ph`
> импортирует библиотеку для работы с ClickHouse

`from scipy import stats`
> импортирует модуль для статистических вычислений

`from scipy.stats import zscore`
> импортирует функцию для вычисления z-оценки

`import pingouin as pg`
> предоставляет различные функции для статистического анализа данных, включая ANOVA, корреляцию, регрессию и др.

`from scipy.special import comb`
> функция comb из библиотеки scipy.special, которая используется для вычисления комбинаторных коэффициентов

`from statsmodels.formula.api import ols`
> интерфейс для моделирования линейной регрессии с помощью формул

`from statsmodels.stats.anova import anova_lm`
> используется для проведения анализа дисперсии (ANOVA) в статистическом анализе данных

`import statsmodels.formula.api as smf`
> работа с формулами и моделями

`import statsmodels.api as sm`
> предоставляет классы и функции для моделирования и статистического анализа данных

`from sklearn.cluster import AgglomerativeClustering`
> используется для кластеризации данных с помощью иерархической кластеризации

`import bootstrapped.bootstrap as bs`<br>`import bootstrapped.stats_functions as bs_stats`
> позволяют оценить распределение статистических показателей, таких как среднее значение, медиана, стандартное отклонение и т.д.

`from statsmodels.stats.contingency_tables import StratifiedTable`
> используется для анализа таблиц сопряженности

`from scipy.stats import chi2_contingency`
> используется для расчета критерия хи-квадрат для таблиц сопряженности

`from df2gspread import df2gspread as d2g`
> функция используется для экспорта данных из pandas DataFrame в Google Sheets

`from oauth2client.service_account import ServiceAccountCredentials`
> используется для аутентификации в Google API с помощью учетных данных службы

`from my_module import my_function`
> содержит функцию или библиотеку функций, специфичных для проекта, над которым работает конкретный автор

## <a name="file">Файловая система, импорт/экспорт данных</a>

### Файловая система

`[x[0] for x in os.walk('my_directory')]`
> выводит список всех папок внутри папки 'my_directory' (включая подпапки)

### Импорт данных

`df = pd.read_csv('C:\\temp\\example.csv')`<br><br>
`df2 = pd.read_csv('C:\\temp\\example2.csv', parse_dates=['date'],  sep=';', dayfirst=True)`
> импорт с локального диска и сохранение файла в датафрейм, во втором примере указан парсинг дат, указан разделитель и формат времени dd/mm/yyyy

`connection_default = {'host': 'link',`<br>
`'database':'default',`<br>
`'user':'******',`<br>
`'password':'******'`<br>
`}`<br>

`q =`<br> 
```
    '''
    SELECT *
    FROM
        {db}.table
    WHERE
        id != 'none'
    ''' 
```
`df = ph.read_clickhouse(query=q, connection=connection_default)`
> SQL запрос в Python через CLICKHOUSE в пандас (нужно подставить link, заменить звездочки учетными данными, верно указать базу данных и написать корректный запрос)

`df = pd.read_csv('C:\\temp\\data.csv.zip',  compression='zip')`<br><br>
`with zipfile.ZipFile('C:\\temp\\data2.csv.zip') as myzip:`<br>
    `with myzip.open('data2.csv') as myfile:`<br>
        `df2 = pd.read_csv(myfile, encoding='ISO-8859-1')`
> импорт в датасет csv файла, а во втором случае импорт конкретного csv файла в архиве

`df = np.genfromtxt('C:\\temp\\data.txt', dtype=None)`<br>
`pd.DataFrame(df)`
> загружает данные из txt файла в виде массива numpy и создает датасет с этими данными

`df = pd.read_excel('C:\\temp\\data.xls')`
> загружает данные из excel файла в виде массива numpy и создает датасет с этими данными

`df = pd.read_csv('link', sep=";")`
> загружает файл csv по ссылке

`def download(link, df):`<br>
    `   base_url = 'link'`<br>
    `   final_url = base_url + urlencode(dict(public_key=link))`<br>
    `   response = requests.get(final_url)`<br>
    `   download_url_file = response.json()['href']`<br>
    `   file_df = pd.read_csv(download_url_file)`<br>
    `   pattern = r'[;,|\t]'`<br>
    `   pattern_test = re.search(pattern, file_df.columns[0])`<br>
    `   if pattern_test is not None:`<br>
        `       sep = pattern_test[0]`<br>
        `       file_df = pd.read_csv(download_url_file, delimiter=None, sep=sep, parse_dates=True)`<br>
    `   globals()[df] = file_df`
> функция для загрузки файлов с ЯндексДиска (заполнить link)

### Экспорт данных

`filename = 'C:\\temp\\data.csv'<br>
`df.to_csv(filename)`
> сохраняет датасет в csv файл

## <a name="string">Работа со строками</a>

`S1 + S2` 
>сложение строк

`S * 3`
повторение строки три раза

`S[i]`
> обращение по индексу символа в строке

`S[i:j:step]`
> позволяет выбрать срез последовательности элементов начиная с индекса i и заканчивая индексом j-1 с заданным шагом step

`len(S)`
> выводит длину строки

`S.find(str, [start],[end])`
> возвращает индекс первого символа первого вхождения str в S или -1, если подстрока не найдена.
> start является необязательным и указывает индекс, с которого нужно начать поиск подстроки. Если start не указан, поиск начинается с начала строки
> end также является необязательным и указывает индекс, до которого нужно искать подстроку. Если end не указан, поиск производится до конца строки

`S.rfind(str, [start],[end])`
> то же что и предыдущее, но возвращает номер последнего вхождения или -1

`S.index(str, [start],[end])`
> аналогично S.find, отличие в том, что если подстрока не найдена, S.index() генерирует исключение ValueError

`S.rindex(str, [start],[end])`
> то же что и предыдущее, но возвращает номер последнего вхождения или ValueError

`S.replace(шаблон, замена)`
> замена символов в строке по шаблону

`S.split(символ)`
> разбиение строки по разделителю, указанному в скобках

`S.isdigit()`
> cостоит ли строка из цифр - возвращает true или false

`S.isalpha()`
> cостоит ли строка из букв - возвращает true или false

`S.isalnum()`
> cостоит ли строка из цифр или букв - возвращает true или false

`S.islower()`
> cостоит ли строка из символов в нижнем регистре - возвращает true или false

`S.isupper()`
>cостоит ли строка из символов в верхнем регистре - возвращает true или false

`S.isspace()`
> cостоит ли строка из неотображаемых символов: пробел, перевод страницы новая строка и т.д. - возвращает true или false

`S.istitle()`
> начинаются ли слова в строке с заглавной буквы - возвращает true или false

`S.upper()`
> преобразовывает строку к верхнему регистру

`S.lower()`
> преобразовывает строку к нижнему регистру

`S.startswith(шаблон)`
> начинается ли строка с шаблона - возвращает true или false

`S.endswith(шаблон)`
> заканчивается ли строка шаблоном - возвращает true или false

`S.join(список)`
> объединяет элементы списка в одну строку S, используя строку S в качестве разделителя между элементами списка

`ord(символ)`
> возвращает код символа в таблице символов ASCII

`chr(число)`
> возвращает символ, соответствующий переданному числу в кодировке Unicode

`S.capitalize()`
> переводит первый символ строки в верхний регистр, а все остальные в нижний

`S.center(width, [fill])`
> выравнивает строку S по центру, путем добавления символов fill (если указано) слева и справа от строки до достижения заданной ширины (width)

`S.count(str, [start],[end])`
> возвращает количество непересекающихся вхождений подстроки в диапазоне [start, end]

`S.expandtabs([tabsize])`
> возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами. Если TabSize не указан, табуляция полагается равным 8 пробелам

`S.lstrip([chars])`
> удаление пробельных символов в начале строки

`S.rstrip([chars])`
> удаление пробельных символов в конце строки

`S.strip([chars])`
> удаление пробельных символов в начале и в конце строки

`S.partition(шаблон)`
> возвращает кортеж из трех элементов: 1й будет содержать часть строки S, которая находится перед первым вхождением шаблона; 2й элемент будет содержать сам шаблон; 3й элемент будет содержать часть строки S, которая находится после первого вхождения шаблона

`S.rpartition(sep)`
> то же самое, что и предыдущая команда, но выполняется в обратном направлении

`S.swapcase()`
> переводит символы нижнего регистра в верхний, а верхнего – в нижний

`S.title()`
> первую букву каждого слова переводит в верхний регистр, а все остальные в нижний

`S.zfill(width)`
> используется для добавления ведущих нулей в строку S до заданной ширины width

`S.ljust(width, fillchar=" ")`
> то же самое, что и предыдущая команда, но заполняет символом fillchar

`S.rjust(width, fillchar=" ")`
> то же самое, что и предыдущая команда, но заполняет символом fillchar и выполняется в обратном направлении
