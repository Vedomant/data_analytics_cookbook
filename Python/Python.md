# Python

## <a name="import">Импорт библиотек</a>

`import pandas as pd`
> импортирует библиотеку для работы с таблицами и данными в виде датафреймов

`import numpy as np`
> импортирует библиотеку для работы с числами

`import seaborn as sns`
> импортирует библиотеку для создания графиков и визуализации данных

`import matplotlib.pyplot as plt`
> импортирует библиотеку для создания графиков и визуализации данных

`import plotly.express as px`
> импортирует библиотеку для создания интерактивных графиков

`import datetime`
> импортирует модуль для работы с датами и временем

`import matplotlib.dates as mdates`
> импортирует модуль для работы с датами и временем в библиотеке matplotlib

`import random`
> импортирует модуль для генерации случайных чисел

`import re`
> импортирует модуль для работы с регулярными выражениями

`import vk_ip`
> импортирует модуль для работы с IP-адресами ВКонтакте

`import os`
> импортирует модуль для работы с операционной системой

`import json as json`
> импортирует модуль для работы с JSON-данными

`import requests`
> импортирует модуль для работы с HTTP-запросами

`import gspread`
> импортирует библиотеку для работы с Google Sheets

`import zipfile`
> импортирует модуль, который предоставляет функции для работы с архивами ZIP в Python

`from io import BytesIO`
> импортирует модуль для работы с бинарными данными в памяти

`import pandahouse as ph`
> импортирует библиотеку для работы с ClickHouse

`from scipy import stats`
> импортирует модуль для статистических вычислений

`from scipy.stats import zscore`
> импортирует функцию для вычисления z-оценки

`import pingouin as pg`
> предоставляет различные функции для статистического анализа данных, включая ANOVA, корреляцию, регрессию и др.

`from scipy.special import comb`
> функция comb из библиотеки scipy.special, которая используется для вычисления комбинаторных коэффициентов

`from statsmodels.formula.api import ols`
> интерфейс для моделирования линейной регрессии с помощью формул

`from statsmodels.stats.anova import anova_lm`
> используется для проведения анализа дисперсии (ANOVA) в статистическом анализе данных

`import statsmodels.formula.api as smf`
> работа с формулами и моделями

`import statsmodels.api as sm`
> предоставляет классы и функции для моделирования и статистического анализа данных

`from sklearn.cluster import AgglomerativeClustering`
> используется для кластеризации данных с помощью иерархической кластеризации

`import bootstrapped.bootstrap as bs`<br>`import bootstrapped.stats_functions as bs_stats`
> позволяют оценить распределение статистических показателей, таких как среднее значение, медиана, стандартное отклонение и т.д.

`from statsmodels.stats.contingency_tables import StratifiedTable`
> используется для анализа таблиц сопряженности

`from scipy.stats import chi2_contingency`
> используется для расчета критерия хи-квадрат для таблиц сопряженности

`from df2gspread import df2gspread as d2g`
> функция используется для экспорта данных из pandas DataFrame в Google Sheets

`from oauth2client.service_account import ServiceAccountCredentials`
> используется для аутентификации в Google API с помощью учетных данных службы

`from my_module import my_function`
> содержит функцию или библиотеку функций, специфичных для проекта, над которым работает конкретный автор

## <a name="file">Файловая система, импорт/экспорт данных</a>

### Файловая система

`[x[0] for x in os.walk('my_directory')]`
> выводит список всех папок внутри папки 'my_directory' (включая подпапки)

### Импорт данных

`df = pd.read_csv('C:\\temp\\example.csv')`<br><br>
`df2 = pd.read_csv('C:\\temp\\example2.csv', parse_dates=['date'],  sep=';', dayfirst=True)`
> импорт с локального диска и сохранение файла в датафрейм, во втором примере указан парсинг дат, указан разделитель и формат времени dd/mm/yyyy

`connection_default = {'host': 'link',`<br>
`'database':'default',`<br>
`'user':'******',`<br>
`'password':'******'`<br>
`}`<br>

`q =`<br> 
```
    '''
    SELECT *
    FROM
        {db}.table
    WHERE
        id != 'none'
    ''' 
```
`df = ph.read_clickhouse(query=q, connection=connection_default)`
> SQL запрос в Python через CLICKHOUSE в пандас (нужно подставить link, заменить звездочки учетными данными, верно указать базу данных и написать корректный запрос)

`df = pd.read_csv('C:\\temp\\data.csv.zip',  compression='zip')`<br><br>
`with zipfile.ZipFile('C:\\temp\\data2.csv.zip') as myzip:`<br>
    `with myzip.open('data2.csv') as myfile:`<br>
        `df2 = pd.read_csv(myfile, encoding='ISO-8859-1')`
> импорт в датасет csv файла, а во втором случае импорт конкретного csv файла в архиве

`df = np.genfromtxt('C:\\temp\\data.txt', dtype=None)`<br>
`pd.DataFrame(df)`
> загружает данные из txt файла в виде массива numpy и создает датасет с этими данными

`df = pd.read_excel('C:\\temp\\data.xls')`
> загружает данные из excel файла в виде массива numpy и создает датасет с этими данными

`df = pd.read_csv('link', sep=";")`
> загружает файл csv по ссылке

`def download(link, df):`<br>
    `   base_url = 'link'`<br>
    `   final_url = base_url + urlencode(dict(public_key=link))`<br>
    `   response = requests.get(final_url)`<br>
    `   download_url_file = response.json()['href']`<br>
    `   file_df = pd.read_csv(download_url_file)`<br>
    `   pattern = r'[;,|\t]'`<br>
    `   pattern_test = re.search(pattern, file_df.columns[0])`<br>
    `   if pattern_test is not None:`<br>
        `       sep = pattern_test[0]`<br>
        `       file_df = pd.read_csv(download_url_file, delimiter=None, sep=sep, parse_dates=True)`<br>
    `   globals()[df] = file_df`
> функция для загрузки файлов с ЯндексДиска (заполнить link)

### Экспорт данных

`filename = 'C:\\temp\\data.csv'<br>
`df.to_csv(filename)`
> сохраняет датасет в csv файл

## <a name="string">Работа со строками</a>

`S1 + S2` 
>сложение строк

`S * 3`
повторение строки три раза

`S[i]`
> обращение по индексу символа в строке

`S[i:j:step]`
> позволяет выбрать срез последовательности элементов начиная с индекса i и заканчивая индексом j-1 с заданным шагом step

`len(S)`
> выводит длину строки

`S.find(str, [start],[end])`
> возвращает индекс первого символа первого вхождения str в S или -1, если подстрока не найдена.
> start является необязательным и указывает индекс, с которого нужно начать поиск подстроки. Если start не указан, поиск начинается с начала строки
> end также является необязательным и указывает индекс, до которого нужно искать подстроку. Если end не указан, поиск производится до конца строки

`S.rfind(str, [start],[end])`
> то же что и предыдущее, но возвращает номер последнего вхождения или -1

`S.index(str, [start],[end])`
> аналогично S.find, отличие в том, что если подстрока не найдена, S.index() генерирует исключение ValueError

`S.rindex(str, [start],[end])`
> то же что и предыдущее, но возвращает номер последнего вхождения или ValueError

`S.replace(шаблон, замена)`
> замена символов в строке по шаблону

`S.split(символ)`
> разбиение строки по разделителю, указанному в скобках

`S.isdigit()`
> cостоит ли строка из цифр - возвращает true или false

`S.isalpha()`
> cостоит ли строка из букв - возвращает true или false

`S.isalnum()`
> cостоит ли строка из цифр или букв - возвращает true или false

`S.islower()`
> cостоит ли строка из символов в нижнем регистре - возвращает true или false

`S.isupper()`
>cостоит ли строка из символов в верхнем регистре - возвращает true или false

`S.isspace()`
> cостоит ли строка из неотображаемых символов: пробел, перевод страницы новая строка и т.д. - возвращает true или false

`S.istitle()`
> начинаются ли слова в строке с заглавной буквы - возвращает true или false

`S.upper()`
> преобразовывает строку к верхнему регистру

`S.lower()`
> преобразовывает строку к нижнему регистру

`S.startswith(шаблон)`
> начинается ли строка с шаблона - возвращает true или false

`S.endswith(шаблон)`
> заканчивается ли строка шаблоном - возвращает true или false

`S.join(список)`
> объединяет элементы списка в одну строку S, используя строку S в качестве разделителя между элементами списка

`ord(символ)`
> возвращает код символа в таблице символов ASCII

`chr(число)`
> возвращает символ, соответствующий переданному числу в кодировке Unicode

`S.capitalize()`
> переводит первый символ строки в верхний регистр, а все остальные в нижний

`S.center(width, [fill])`
> выравнивает строку S по центру, путем добавления символов fill (если указано) слева и справа от строки до достижения заданной ширины (width)

`S.count(str, [start],[end])`
> возвращает количество непересекающихся вхождений подстроки в диапазоне [start, end]

`S.expandtabs([tabsize])`
> возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами. Если TabSize не указан, табуляция полагается равным 8 пробелам

`S.lstrip([chars])`
> удаление пробельных символов в начале строки

`S.rstrip([chars])`
> удаление пробельных символов в конце строки

`S.strip([chars])`
> удаление пробельных символов в начале и в конце строки

`S.partition(шаблон)`
> возвращает кортеж из трех элементов: 1й будет содержать часть строки S, которая находится перед первым вхождением шаблона; 2й элемент будет содержать сам шаблон; 3й элемент будет содержать часть строки S, которая находится после первого вхождения шаблона

`S.rpartition(sep)`
> то же самое, что и предыдущая команда, но выполняется в обратном направлении

`S.swapcase()`
> переводит символы нижнего регистра в верхний, а верхнего – в нижний

`S.title()`
> первую букву каждого слова переводит в верхний регистр, а все остальные в нижний

`S.zfill(width)`
> используется для добавления ведущих нулей в строку S до заданной ширины width

`S.ljust(width, fillchar=" ")`
> то же самое, что и предыдущая команда, но заполняет символом fillchar

`S.rjust(width, fillchar=" ")`
> то же самое, что и предыдущая команда, но заполняет символом fillchar и выполняется в обратном направлении

## <a name="list">Работа со списками</a>

`append()`
> добавляет в конец списка один новый элемент

`extend()`
> расширяет список другим списком

`insert(index, value)`
> позволяет вставлять значение в список в заданной позиции

`index()`
> возвращает индекс первого элемента, значение которого равняется переданному в метод значению

`remove()`
> удаляет первый элемент, значение которого равняется переданному в метод значению

`pop(index)`
> удаляет элемент по указанному индексу и возвращает его

`reverse()`
> меняет на противоположный порядок следования значений в списке

`len(list)`
> выводит количество элементов списка

`sum(list)`
> выводит сумму элементов в списке

`count()`
> возвращает количество элементов в списке, значения которых равны переданному в метод значению

`clear()`
> удаляет все элементы из списка

`copy()`
> создает поверхностную копию списка

`sort()`
> сортирует список, для обратного порядка указать reverse

### Списочные выражения

Дано:<br>
`word = 'test'`<br>
`numbers = [1, 5, 10, 25, 50]`<br>
`words = ['house', 'worm', 'sex']`<br>
`str_numbers` = '12345'`<br>
`mix = [1, 'house', 3.45]`

тогда:

| Выражение | Суть | Результат |
| ----------|------|-----------|
| [0 for i in range(10)]| создает список, содержащий определенное количество заданных элементов | [0, 0, 0, 0, 0] |
| [int(i) for i in str_numbers] | преобразует список строк из чисел в список целых чисел | [1, 2, 3, 4, 5] |
| [i ** 3 for i in range(1, 5)] | list comprehension, которое в данном случае генерит список кубов чисел in range | [1, 8, 27, 64] |
| [i for i in numbers if i != 10] | удаляет элементы из списка по условию | [1, 5, 25, 50] |
| [i * 2 for i in numbers]| создаст список, в котором каждый элемент "numbers" будет умножен на 2 | [2, 10, 20, 50, 100] |
|len([item for item in numbers if item > 5]) | вычисляет количество элементов списка numbers, которые больше 5 | 3 |
| [w * 2 for w in word] | создаст список с удвоенными значениями элементов word | ['tt', 'ee', 'ss', 'tt'] |
| [l[0] for l in words] | создаст список, содержащий первый элемент от каждого элемента списка words | ['h', 'w', 's'] |
| all(numbers[i] <= numbers[i+1] for i in range(len(numbers)-1)) | проверяет условие, что каждый последующий элемент списка "numbers" не меньше предыдущего элемента | True |
| [i for i in numbers if i < 15] | вернет список с элементами списка "numbers", которые меньше 15 | [1, 5, 10] |
| [l[0] for l in words if len(l) == 3] | вернет список из первых элементов каждого элемента списка words, длина которого равна 3 | ['s'] |

### Прочие методы

Дано:<br>
`word = 'test'`<br>
`numbers = [1, 5, 10, 25, 50]`<br>
`words = ['house', 'worm', 'sex']`<br>
`str_numbers` = '12345'`<br>
`mix = [1, 'house', 3.45]`

`for num, word in zip(numbers, words):`<br>
&nbsp;&nbsp;&nbsp;&nbsp;`print(f"{num} {word}")`<br>
`1 house`<br>
`5 worm`<br>
`10 sex`<br>
> использована функция zip() для создания итератора, который позволяет проходить по двум спискам одновременно

`result = 1`<br>
`for i in range(0,len(numbers)):`<br>
&nbsp;&nbsp;&nbsp;&nbsp;`result = result * numbers[i]`<br>
`print(result)`<br>
`62500`
> перемножает все числа в списке "numbers" по очереди и сохраняет результат в переменной "result"

`print(list(map(type, mix)))`<br>
`[<class 'int'>, <class 'str'>, <class 'float'>]`
> выведет список, содержащий тип каждого элемента списка

`if len(set(numbers)) == 1:`<br>
&nbsp;&nbsp;&nbsp;&nbsp;`print('YES')`<br>
`else:`<br>
&nbsp;&nbsp;&nbsp;&nbsp;`print('NO')`<br>
`NO`<br>
> код проверяет, все ли элементы списка numbers равны между собой

`n = int(input())`<br>
`counter = []`<br>
`while n != 0:`<br>
&nbsp;&nbsp;&nbsp;&nbsp;`last_digit = n % 10`<br>
&nbsp;&nbsp;&nbsp;&nbsp;`n = n // 10`<br>
&nbsp;&nbsp;&nbsp;&nbsp;`counter.append(last_digit)`<br>
`counter.reverse()`<br>
`print(counter)`<br>
> выводит список цифр введенного пользователем числа в порядке от первой цифры до последней, и для числа 456 результатом будет [4, 5, 6]

## <a name="pandas">Работа с датафреймами (Pandas / NumPy)</a>


`df = pd.DataFrame()`
> cоздает пустой датафрейм

`df = df.reset_index()`
> возвращает датафрейм с новым индексом, начинающимся с 0, и старым индексом, сохраненным в виде нового столбца

`df.isna().sum()`
> возвращает количество пропущенных значений в каждом столбце

`df.columns = [x.lower() for x in df.columns]`
> приводит все названия столбцов к нижнему регистру

`df = df.rename(columns={'x': 'name', 'y': 'new_name'})`
> переименовывает столбец в датасете

`df = df.rename(columns={df.columns[0]:"new_column_name"})`
> переименовывает столбец в датасете по индексу

`df.columns = df.columns.str.replace('[.]', '_').str.replace('[ ]', '').lower()`
> переименовывает столбец в датасете, удаляя "лишние" символы и переводит к нижнему регистру

`df = df.drop(['column_1','column_2'], axis=1)`
`df = df.loc[:,('column_1', 'column_4', 'column_7')]`
`df = df.drop(columns=df.columns[0])`
> удаление столбцов в датасете:<br> первый - удаляет указанные столбцы;<br> второй - удаляет все столбцы, кроме указанных;<br> третий - удаляет столбцы по индексу

`df['numbers'] = df['numbers'].astype(int)`<br>
`df = df.apply(lambda x: pd.to_numeric(x, errors='coerce')).dropna()`
> первый код переводит текстовые значения в целые числа,<br>
> второй код позволяет также удалить все строки с некорректными или отсутствующими значениями - оставить только строки с числовыми значениями

`len(df.loc[df.assign_type != df.reserved_type])`
> позволяет вывести количество строк не соответствующих строкам другого столбца

`df.groupby('year').month.agg(pd.Series.mode)`
> группирует строки по году и для каждой группы найдет моду (самое часто встречающееся значение), в данном случае, месяца

`df = df.astype({"a": int, "b": complex})`
> меняет типы данных в столбцах
